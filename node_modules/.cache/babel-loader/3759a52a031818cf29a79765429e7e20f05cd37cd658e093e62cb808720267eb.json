{"ast":null,"code":"import { colorToRgb, getDistances, getStyleFromRgb } from \"../../Utils\";\nimport { Vector } from \"../../Core\";\nexport function drawPolygonMask(context, rawData, stroke) {\n  const color = colorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n  for (const item of rawData) {\n    context.lineTo(item.x, item.y);\n  }\n  context.closePath();\n  context.strokeStyle = getStyleFromRgb(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n  context.translate(position.x, position.y);\n  const color = colorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n  var _a;\n  const res = [];\n  for (const path of paths) {\n    const segments = path.element.pathSegList;\n    const len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0;\n    const p = {\n      x: 0,\n      y: 0\n    };\n    for (let i = 0; i < len; i++) {\n      const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n      const svgPathSeg = window.SVGPathSeg;\n      switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n        case svgPathSeg.PATHSEG_MOVETO_ABS:\n        case svgPathSeg.PATHSEG_LINETO_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n        case svgPathSeg.PATHSEG_ARC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n          {\n            const absSeg = segment;\n            p.x = absSeg.x;\n            p.y = absSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n          p.x = segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n          p.y = segment.y;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_REL:\n        case svgPathSeg.PATHSEG_MOVETO_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n        case svgPathSeg.PATHSEG_ARC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n          {\n            const relSeg = segment;\n            p.x += relSeg.x;\n            p.y += relSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n          p.x += segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n          p.y += segment.y;\n          break;\n        case svgPathSeg.PATHSEG_UNKNOWN:\n        case svgPathSeg.PATHSEG_CLOSEPATH:\n          continue;\n      }\n      res.push({\n        x: p.x * scale + offset.x,\n        y: p.y * scale + offset.y\n      });\n    }\n  }\n  return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n  const {\n    dx,\n    dy\n  } = getDistances(pos, s1);\n  const {\n    dx: dxx,\n    dy: dyy\n  } = getDistances(s2, s1);\n  const t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2);\n  const res = {\n    x: s1.x + dxx * t,\n    y: s1.x + dyy * t,\n    isOnSegment: t >= 0 && t <= 1\n  };\n  if (t < 0) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > 1) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n  return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n  const {\n    dx,\n    dy\n  } = getDistances(start, stop);\n  const wallAngle = Math.atan2(dy, dx);\n  const wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle));\n  const d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}","map":{"version":3,"names":["colorToRgb","getDistances","getStyleFromRgb","Vector","drawPolygonMask","context","rawData","stroke","color","beginPath","moveTo","x","y","item","lineTo","closePath","strokeStyle","lineWidth","width","drawPolygonMaskPath","path","position","translate","opacity","parsePaths","paths","scale","offset","_a","res","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","calcClosestPtOnSegment","s1","s2","pos","dx","dy","dxx","dyy","t","isOnSegment","segmentBounce","start","stop","velocity","wallAngle","Math","atan2","wallNormal","create","sin","cos","d","multTo","subFrom"],"sources":["/Users/nessakodo/coding/kodo/nessakodo.github.io/node_modules/tsparticles/esm/Plugins/PolygonMask/Utils.js"],"sourcesContent":["import { colorToRgb, getDistances, getStyleFromRgb } from \"../../Utils\";\nimport { Vector } from \"../../Core\";\nexport function drawPolygonMask(context, rawData, stroke) {\n    const color = colorToRgb(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.beginPath();\n    context.moveTo(rawData[0].x, rawData[0].y);\n    for (const item of rawData) {\n        context.lineTo(item.x, item.y);\n    }\n    context.closePath();\n    context.strokeStyle = getStyleFromRgb(color);\n    context.lineWidth = stroke.width;\n    context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n    context.translate(position.x, position.y);\n    const color = colorToRgb(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n    context.lineWidth = stroke.width;\n    context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n    var _a;\n    const res = [];\n    for (const path of paths) {\n        const segments = path.element.pathSegList;\n        const len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0;\n        const p = {\n            x: 0,\n            y: 0,\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n            const svgPathSeg = window.SVGPathSeg;\n            switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\n                case svgPathSeg.PATHSEG_LINETO_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                case svgPathSeg.PATHSEG_ARC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\n                    const absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_REL:\n                case svgPathSeg.PATHSEG_MOVETO_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                case svgPathSeg.PATHSEG_ARC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\n                    const relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_UNKNOWN:\n                case svgPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n            }\n            res.push({\n                x: p.x * scale + offset.x,\n                y: p.y * scale + offset.y,\n            });\n        }\n    }\n    return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n    const { dx, dy } = getDistances(pos, s1);\n    const { dx: dxx, dy: dyy } = getDistances(s2, s1);\n    const t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2);\n    const res = {\n        x: s1.x + dxx * t,\n        y: s1.x + dyy * t,\n        isOnSegment: t >= 0 && t <= 1,\n    };\n    if (t < 0) {\n        res.x = s1.x;\n        res.y = s1.y;\n    }\n    else if (t > 1) {\n        res.x = s2.x;\n        res.y = s2.y;\n    }\n    return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n    const { dx, dy } = getDistances(start, stop);\n    const wallAngle = Math.atan2(dy, dx);\n    const wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle));\n    const d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n    wallNormal.multTo(d);\n    velocity.subFrom(wallNormal);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}