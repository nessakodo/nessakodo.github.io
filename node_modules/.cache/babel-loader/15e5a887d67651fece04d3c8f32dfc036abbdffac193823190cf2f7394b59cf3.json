{"ast":null,"code":"import { colorMix, colorToRgb, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nimport { getDistance, getDistances } from \"./NumberUtils\";\nfunction drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\nfunction drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n  context.save();\n  context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n  context.fillRect(0, 0, dimension.width, dimension.height);\n  context.restore();\n}\nexport function clear(context, dimension) {\n  context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n  let drawn = false;\n  if (getDistance(begin, end) <= maxDistance) {\n    drawLine(context, begin, end);\n    drawn = true;\n  } else if (warp) {\n    let pi1;\n    let pi2;\n    const endNE = {\n      x: end.x - canvasSize.width,\n      y: end.y\n    };\n    const d1 = getDistances(begin, endNE);\n    if (d1.distance <= maxDistance) {\n      const yi = begin.y - d1.dy / d1.dx * begin.x;\n      pi1 = {\n        x: 0,\n        y: yi\n      };\n      pi2 = {\n        x: canvasSize.width,\n        y: yi\n      };\n    } else {\n      const endSW = {\n        x: end.x,\n        y: end.y - canvasSize.height\n      };\n      const d2 = getDistances(begin, endSW);\n      if (d2.distance <= maxDistance) {\n        const yi = begin.y - d2.dy / d2.dx * begin.x;\n        const xi = -yi / (d2.dy / d2.dx);\n        pi1 = {\n          x: xi,\n          y: 0\n        };\n        pi2 = {\n          x: xi,\n          y: canvasSize.height\n        };\n      } else {\n        const endSE = {\n          x: end.x - canvasSize.width,\n          y: end.y - canvasSize.height\n        };\n        const d3 = getDistances(begin, endSE);\n        if (d3.distance <= maxDistance) {\n          const yi = begin.y - d3.dy / d3.dx * begin.x;\n          const xi = -yi / (d3.dy / d3.dx);\n          pi1 = {\n            x: xi,\n            y: yi\n          };\n          pi2 = {\n            x: pi1.x + canvasSize.width,\n            y: pi1.y + canvasSize.height\n          };\n        }\n      }\n    }\n    if (pi1 && pi2) {\n      drawLine(context, begin, pi1);\n      drawLine(context, end, pi2);\n      drawn = true;\n    }\n  }\n  if (!drawn) {\n    return;\n  }\n  context.lineWidth = width;\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n  context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n  if (shadow.enable) {\n    const shadowColor = colorToRgb(shadow.color);\n    if (shadowColor) {\n      context.shadowBlur = shadow.blur;\n      context.shadowColor = getStyleFromRgb(shadowColor);\n    }\n  }\n  context.stroke();\n}\nexport function drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n  drawTriangle(context, pos1, pos2, pos3);\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n  context.fillStyle = getStyleFromRgb(colorTriangle, opacityTriangle);\n  context.fill();\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n  context.save();\n  drawLine(context, begin, end);\n  context.lineWidth = width;\n  context.strokeStyle = lineStyle;\n  context.stroke();\n  context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n  const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n  const color1 = p1.getFillColor();\n  const color2 = p2.getFillColor();\n  if (!color1 || !color2) {\n    return;\n  }\n  const sourcePos = p1.getPosition();\n  const destPos = p2.getPosition();\n  const midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius());\n  const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n  grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n  grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n  grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n  return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n  context.save();\n  drawLine(context, begin, end);\n  context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n  context.lineWidth = width;\n  context.stroke();\n  context.restore();\n}\nexport function drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow, gradient) {\n  var _a, _b, _c, _d, _e, _f;\n  const pos = particle.getPosition();\n  const tiltOptions = particle.options.tilt;\n  const rollOptions = particle.options.roll;\n  context.save();\n  if (tiltOptions.enable || rollOptions.enable) {\n    const roll = rollOptions.enable && particle.roll;\n    const tilt = tiltOptions.enable && particle.tilt;\n    const rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\");\n    const rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n    context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n  context.beginPath();\n  const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n  const shadowColor = particle.shadowColor;\n  if (shadow.enable && shadowColor) {\n    context.shadowBlur = shadow.blur;\n    context.shadowColor = getStyleFromRgb(shadowColor);\n    context.shadowOffsetX = shadow.offset.x;\n    context.shadowOffsetY = shadow.offset.y;\n  }\n  if (gradient) {\n    const gradientAngle = gradient.angle.value;\n    const fillGradient = gradient.type === \"radial\" ? context.createRadialGradient(0, 0, 0, 0, 0, radius) : context.createLinearGradient(Math.cos(gradientAngle) * -radius, Math.sin(gradientAngle) * -radius, Math.cos(gradientAngle) * radius, Math.sin(gradientAngle) * radius);\n    for (const color of gradient.colors) {\n      fillGradient.addColorStop(color.stop, getStyleFromHsl({\n        h: color.value.h.value,\n        s: color.value.s.value,\n        l: color.value.l.value\n      }, (_d = (_c = color.opacity) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : opacity));\n    }\n    context.fillStyle = fillGradient;\n  } else {\n    if (fillColorValue) {\n      context.fillStyle = fillColorValue;\n    }\n  }\n  const stroke = particle.stroke;\n  context.lineWidth = (_e = particle.strokeWidth) !== null && _e !== void 0 ? _e : 0;\n  if (strokeColorValue) {\n    context.strokeStyle = strokeColorValue;\n  }\n  drawShape(container, context, particle, radius, opacity, delta);\n  if (((_f = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _f !== void 0 ? _f : 0) > 0) {\n    context.stroke();\n  }\n  if (particle.close) {\n    context.closePath();\n  }\n  if (particle.fill) {\n    context.fill();\n  }\n  context.restore();\n  context.save();\n  if (tiltOptions.enable && particle.tilt) {\n    context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n  drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n  context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n  const drawer = container.drawers.get(particle.shape);\n  if (!drawer) {\n    return;\n  }\n  drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n  const drawer = container.drawers.get(particle.shape);\n  if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n    return;\n  }\n  drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n  if (!plugin.draw) {\n    return;\n  }\n  context.save();\n  plugin.draw(context, delta);\n  context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n  if (plugin.drawParticle !== undefined) {\n    context.save();\n    plugin.drawParticle(context, particle, delta);\n    context.restore();\n  }\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n  const pos = particle.getPosition();\n  if (fillColorValue) {\n    context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n  }\n  if (width === 0) {\n    return;\n  }\n  context.lineWidth = width;\n  const rotationRadian = rotation * Math.PI / 180;\n  context.beginPath();\n  context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n  context.stroke();\n}\nexport function alterHsl(color, type, value) {\n  return {\n    h: color.h,\n    s: color.s,\n    l: color.l + (type === \"darken\" ? -1 : 1) * value\n  };\n}","map":{"version":3,"names":["colorMix","colorToRgb","getStyleFromHsl","getStyleFromRgb","getDistance","getDistances","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","paintBase","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawLinkLine","maxDistance","canvasSize","warp","backgroundMask","composite","colorLine","opacity","shadow","drawn","pi1","pi2","endNE","d1","distance","yi","dy","dx","endSW","d2","xi","endSE","d3","lineWidth","globalCompositeOperation","strokeStyle","enable","shadowColor","color","shadowBlur","blur","stroke","drawLinkTriangle","pos1","pos2","pos3","colorTriangle","opacityTriangle","fill","drawConnectLine","lineStyle","gradient","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","grad","createLinearGradient","addColorStop","drawGrabLine","drawParticle","container","particle","delta","fillColorValue","strokeColorValue","radius","_a","_b","_c","_d","_e","_f","pos","tiltOptions","options","tilt","rollOptions","roll","rollHorizontal","mode","rollVertical","setTransform","cos","angle","value","cosDirection","sin","sinDirection","translate","rotate","path","velocity","shadowOffsetX","offset","shadowOffsetY","gradientAngle","fillGradient","type","createRadialGradient","colors","stop","h","s","l","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","drawParticlePlugin","undefined","drawEllipse","rotation","start","rotationRadian","PI","ellipse","alterHsl"],"sources":["/Users/nessakodo/coding/kodo/nessakodo.github.io/node_modules/tsparticles/esm/Utils/CanvasUtils.js"],"sourcesContent":["import { colorMix, colorToRgb, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nimport { getDistance, getDistances } from \"./NumberUtils\";\nfunction drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n}\nfunction drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n}\nexport function clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n    let drawn = false;\n    if (getDistance(begin, end) <= maxDistance) {\n        drawLine(context, begin, end);\n        drawn = true;\n    }\n    else if (warp) {\n        let pi1;\n        let pi2;\n        const endNE = {\n            x: end.x - canvasSize.width,\n            y: end.y,\n        };\n        const d1 = getDistances(begin, endNE);\n        if (d1.distance <= maxDistance) {\n            const yi = begin.y - (d1.dy / d1.dx) * begin.x;\n            pi1 = { x: 0, y: yi };\n            pi2 = { x: canvasSize.width, y: yi };\n        }\n        else {\n            const endSW = {\n                x: end.x,\n                y: end.y - canvasSize.height,\n            };\n            const d2 = getDistances(begin, endSW);\n            if (d2.distance <= maxDistance) {\n                const yi = begin.y - (d2.dy / d2.dx) * begin.x;\n                const xi = -yi / (d2.dy / d2.dx);\n                pi1 = { x: xi, y: 0 };\n                pi2 = { x: xi, y: canvasSize.height };\n            }\n            else {\n                const endSE = {\n                    x: end.x - canvasSize.width,\n                    y: end.y - canvasSize.height,\n                };\n                const d3 = getDistances(begin, endSE);\n                if (d3.distance <= maxDistance) {\n                    const yi = begin.y - (d3.dy / d3.dx) * begin.x;\n                    const xi = -yi / (d3.dy / d3.dx);\n                    pi1 = { x: xi, y: yi };\n                    pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                }\n            }\n        }\n        if (pi1 && pi2) {\n            drawLine(context, begin, pi1);\n            drawLine(context, end, pi2);\n            drawn = true;\n        }\n    }\n    if (!drawn) {\n        return;\n    }\n    context.lineWidth = width;\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    if (shadow.enable) {\n        const shadowColor = colorToRgb(shadow.color);\n        if (shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = getStyleFromRgb(shadowColor);\n        }\n    }\n    context.stroke();\n}\nexport function drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n    drawTriangle(context, pos1, pos2, pos3);\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    context.fillStyle = getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n    const color1 = p1.getFillColor();\n    const color2 = p2.getFillColor();\n    if (!color1 || !color2) {\n        return;\n    }\n    const sourcePos = p1.getPosition();\n    const destPos = p2.getPosition();\n    const midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius());\n    const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n    return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    drawLine(context, begin, end);\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n}\nexport function drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow, gradient) {\n    var _a, _b, _c, _d, _e, _f;\n    const pos = particle.getPosition();\n    const tiltOptions = particle.options.tilt;\n    const rollOptions = particle.options.roll;\n    context.save();\n    if (tiltOptions.enable || rollOptions.enable) {\n        const roll = rollOptions.enable && particle.roll;\n        const tilt = tiltOptions.enable && particle.tilt;\n        const rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\");\n        const rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n        context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    context.beginPath();\n    const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    const shadowColor = particle.shadowColor;\n    if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n    }\n    if (gradient) {\n        const gradientAngle = gradient.angle.value;\n        const fillGradient = gradient.type === \"radial\"\n            ? context.createRadialGradient(0, 0, 0, 0, 0, radius)\n            : context.createLinearGradient(Math.cos(gradientAngle) * -radius, Math.sin(gradientAngle) * -radius, Math.cos(gradientAngle) * radius, Math.sin(gradientAngle) * radius);\n        for (const color of gradient.colors) {\n            fillGradient.addColorStop(color.stop, getStyleFromHsl({\n                h: color.value.h.value,\n                s: color.value.s.value,\n                l: color.value.l.value,\n            }, (_d = (_c = color.opacity) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : opacity));\n        }\n        context.fillStyle = fillGradient;\n    }\n    else {\n        if (fillColorValue) {\n            context.fillStyle = fillColorValue;\n        }\n    }\n    const stroke = particle.stroke;\n    context.lineWidth = (_e = particle.strokeWidth) !== null && _e !== void 0 ? _e : 0;\n    if (strokeColorValue) {\n        context.strokeStyle = strokeColorValue;\n    }\n    drawShape(container, context, particle, radius, opacity, delta);\n    if (((_f = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _f !== void 0 ? _f : 0) > 0) {\n        context.stroke();\n    }\n    if (particle.close) {\n        context.closePath();\n    }\n    if (particle.fill) {\n        context.fill();\n    }\n    context.restore();\n    context.save();\n    if (tiltOptions.enable && particle.tilt) {\n        context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!drawer) {\n        return;\n    }\n    drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n    }\n    drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n    if (!plugin.draw) {\n        return;\n    }\n    context.save();\n    plugin.draw(context, delta);\n    context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n    if (plugin.drawParticle !== undefined) {\n        context.save();\n        plugin.drawParticle(context, particle, delta);\n        context.restore();\n    }\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n    const pos = particle.getPosition();\n    if (fillColorValue) {\n        context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n    }\n    if (width === 0) {\n        return;\n    }\n    context.lineWidth = width;\n    const rotationRadian = (rotation * Math.PI) / 180;\n    context.beginPath();\n    context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n    context.stroke();\n}\nexport function alterHsl(color, type, value) {\n    return {\n        h: color.h,\n        s: color.s,\n        l: color.l + (type === \"darken\" ? -1 : 1) * value,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}